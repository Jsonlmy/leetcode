class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    '''
    打家劫舍1

    你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

    给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

    示例 1:

    输入: [1,2,3,1]
    输出: 4
    解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
         偷窃到的最高金额 = 1 + 3 = 4 。
    示例 2:

    输入: [2,7,9,3,1]
    输出: 12
    解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
         偷窃到的最高金额 = 2 + 9 + 1 = 12 。

    链接：https://leetcode-cn.com/problems/house-robber
    '''
    def rob(self, nums: list) -> int:
        '''
        解法1：动态规划，f(k)为偷到第k间房的最优解，当遇到第i间房时，有两个选择，偷与不偷，
        若f(k-2)加上第i间房的钱大于f(k-1)就选择偷
        f(k) = max(f(k-2) + A[i], f(k-1))
        '''
        nums = [0, 0] + nums
        for i in range(2, len(nums)):
            nums[i] = max(nums[i-2] + nums[i], nums[i-1])
        return nums[-1]

    '''
    打家劫舍2

    你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

    给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

    示例 1:

    输入: [2,3,2]
    输出: 3
    解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
    示例 2:

    输入: [1,2,3,1]
    输出: 4
    解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
         偷窃到的最高金额 = 1 + 3 = 4 。

    链接：https://leetcode-cn.com/problems/house-robber-ii
    '''
    def rob2(self, nums: list) -> int:
        '''
        偷第一家就不能偷最后一家，偷最后一家就不能偷第一家，分成nums[:-1]，nums[1:]就变成题1了
        '''
        return max(self.rob(nums[1:]), self.rob(nums[:-1])) if len(nums) < 2 else sum(nums)
    
    '''
    打家劫舍3
    
    在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

    计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

    示例 1:

    输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

    输出: 7 
    解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
    示例 2:

    输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

    输出: 9
    解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.

    链接：https://leetcode-cn.com/problems/house-robber-iii
    '''
    def rob3(self, root: TreeNode) -> int:
        '''
        解法1：树形动态规划，前序遍历
        '''
        return max(self.dfs(root))
 

    def dfs(self, cur: TreeNode) -> List[int] :
        # 前序遍历，自底向上
        if not cur :
            return [0,0]
        
        l = self.dfs(cur.left)      # l = [左子树中不选左子节点能达到的最大收益, 左子树选左子节点能达到的最大收益]
        r = self.dfs(cur.right)     # r同理

        # [不选当前节点的最大收益=左右子树各自最大收益，选当前节点的最大收益=当前节点收益+左右子树不选其根节点的最大收益]
        return [max(l)+max(r), cur.val+l[0]+r[0]]
 





if __name__ == "__main__":
    print(Solution().rob2([1,2,1,1]))